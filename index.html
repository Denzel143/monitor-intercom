<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Program 2 - Monitor Intercom</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body, html { width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: Arial, sans-serif; }
        
        #video-wrapper {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }

        #remote-video, #detection-canvas {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(1) translate(0px, 0px);
            width: 100%; height: 100%; object-fit: cover;
            transition: transform 0.1s ease-out; 
        }

        #detection-canvas { z-index: 2; pointer-events: none; }
        
        .status-message {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7); color: white; padding: 20px;
            border-radius: 10px; text-align: center; z-index: 5;
        }
        
        #motion-status {
            position: fixed; bottom: 20px; left: 20px;
            background-color: rgba(200, 0, 0, 0.75); color: white;
            padding: 8px 15px; border-radius: 5px; z-index: 10;
            font-weight: bold; font-size: 14px; transition: opacity 0.3s;
        }

        .hidden { display: none; }

        .controls {
            position: fixed; bottom: 20px; right: 20px; z-index: 10;
            display: flex; gap: 15px;
        }
        .control-button {
            width: 60px; height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid white; border-radius: 50%;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            color: white; transition: background-color 0.2s;
        }
        .control-button:hover { background-color: rgba(255, 255, 255, 0.3); }
        .control-button.active { background-color: #d93025; }
        .control-button.unmuted { background-color: #1a73e8; }
        
        .control-button.replay { border-color: #fbbc04; color: #fbbc04; }
        .control-button.replay:hover { background-color: rgba(251, 188, 4, 0.2); }

        /* --- ZOOM & PAN CONTROLS --- */
        #ptz-controls {
            position: fixed; top: 20px; right: 20px; z-index: 15;
            background-color: rgba(0, 0, 0, 0.6); padding: 15px;
            border-radius: 10px; display: flex; flex-direction: column;
            align-items: center; gap: 10px; border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .zoom-container { width: 100%; text-align: center; color: white; font-size: 12px; margin-bottom: 5px; }
        #zoom-slider { width: 120px; cursor: pointer; }
        .pan-grid { display: grid; grid-template-columns: 40px 40px 40px; grid-template-rows: 40px 40px 40px; gap: 5px; }
        .pan-btn {
            background-color: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.5);
            color: white; border-radius: 5px; cursor: pointer; font-size: 18px;
            display: flex; justify-content: center; align-items: center; transition: all 0.2s;
        }
        .pan-btn:hover:not(:disabled) { background-color: rgba(255, 255, 255, 0.4); }
        .pan-btn:active:not(:disabled) { background-color: rgba(255, 255, 255, 0.6); }
        .pan-btn:disabled { background-color: rgba(50, 50, 50, 0.5); color: rgba(255, 255, 255, 0.2); cursor: not-allowed; pointer-events: none; }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-reset { grid-column: 2; grid-row: 2; font-size: 12px; font-weight: bold; background-color: rgba(255, 0, 0, 0.4); }
        #btn-right { grid-column: 3; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 3; }
        
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); color: white;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; text-align: center; cursor: pointer;
        }
        #start-overlay-content { padding: 30px; max-width: 80%; background-color: rgba(50, 50, 50, 0.8); border-radius: 15px; }
        #start-button {
            background-color: #4CAF50; color: white; border: none; padding: 12px 24px;
            font-size: 18px; border-radius: 8px; cursor: pointer; margin-top: 20px;
        }

        /* --- UI REPLAY / DVR / MEMORY --- */
        #memory-indicator {
            position: fixed; top: 20px; left: 20px; z-index: 15;
            background-color: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 8px;
            color: white; font-size: 12px; border: 1px solid rgba(255,255,255,0.3);
            min-width: 170px;
        }
        #ram-bar-container { width: 100%; height: 10px; background: #333; margin-top: 5px; border-radius: 5px; overflow: hidden; }
        #ram-bar-fill { height: 100%; background: #4CAF50; width: 0%; transition: width 0.5s; }
        #ram-text { margin-top: 5px; font-weight: bold; }
        
        /* STYLE INDIKATOR DURASI BARU */
        #duration-text {
            margin-top: 5px; 
            padding-top: 5px; 
            border-top: 1px solid rgba(255,255,255,0.2); 
            color: #ddd; 
            font-family: monospace; 
            font-size: 13px;
        }

        #replay-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; z-index: 200; flex-direction: column;
        }
        #replay-header {
            height: 60px; background-color: #222; display: flex; align-items: center;
            padding: 0 20px; justify-content: space-between; border-bottom: 1px solid #444;
        }
        #replay-title { color: white; font-size: 18px; font-weight: bold; }
        #close-replay-btn {
            background: #d93025; color: white; border: none; padding: 8px 16px;
            border-radius: 5px; cursor: pointer; font-weight: bold;
        }
        #replay-video-container { flex: 1; display: flex; justify-content: center; align-items: center; background: #111; }
        #replay-video { max-width: 100%; max-height: 100%; }
        
    </style>
</head>
<body>
    <div id="start-overlay">
        <div id="start-overlay-content">
            <h2>Monitor Penerima - DVR System</h2>
            <p>Klik untuk memulai Monitoring & Perekaman.</p>
            <button id="start-button">Mulai</button>
        </div>
    </div>

    <div id="ptz-controls">
        <div class="zoom-container">
            <label for="zoom-slider">Digital Zoom</label><br>
            <input type="range" id="zoom-slider" min="1" max="5" step="0.1" value="1">
        </div>
        <div class="pan-grid">
            <button id="btn-up" class="pan-btn" disabled>▲</button>
            <button id="btn-left" class="pan-btn" disabled>◀</button>
            <button id="btn-reset" class="pan-btn">RST</button>
            <button id="btn-right" class="pan-btn" disabled>▶</button>
            <button id="btn-down" class="pan-btn" disabled>▼</button>
        </div>
    </div>

    <div id="memory-indicator">
        <div>DVR Buffer (RAM)</div>
        <div id="ram-bar-container"><div id="ram-bar-fill"></div></div>
        <div id="ram-text">0 MB / 1 GB</div>
        <div id="duration-text">Durasi: 00:00:00</div>
    </div>

    <div id="video-wrapper">
        <video id="remote-video" autoplay playsinline muted></video>
        <canvas id="detection-canvas"></canvas>
    </div>

    <div id="replay-overlay">
        <div id="replay-header">
            <div id="replay-title">Replay Mode (Rekaman Latar Belakang Tetap Berjalan)</div>
            <button id="close-replay-btn">Tutup & Kembali ke Live</button>
        </div>
        <div id="replay-video-container">
            <video id="replay-video" controls autoplay></video>
        </div>
    </div>

    <div class="status-message" id="statusMessage">
        <h2>Monitor Penerima</h2>
        <p>Menunggu sinyal video...</p>
    </div>

    <div id="motion-status" class="hidden">MOTION DETECTED</div>

    <div class="controls">
        <div id="toggle-audio-btn" class="control-button"></div>
        <div id="toggle-beep-btn" class="control-button"></div>
        
        <div id="replay-btn" class="control-button replay" title="Replay Video">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        </div>

        <div id="push-to-talk-btn" class="control-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line></svg>
        </div>
    </div>
    
    <canvas id="motion-comparison-canvas" style="display:none;"></canvas>

    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <script>
        const remoteVideoElement = document.getElementById('remote-video');
        const canvasElement = document.getElementById('detection-canvas');
        const videoWrapper = document.getElementById('video-wrapper');
        const statusMessage = document.getElementById('statusMessage');
        const toggleAudioBtn = document.getElementById('toggle-audio-btn');
        const pushToTalkBtn = document.getElementById('push-to-talk-btn');
        const startOverlay = document.getElementById('start-overlay');
        const startButton = document.getElementById('start-button');
        const toggleBeepBtn = document.getElementById('toggle-beep-btn');

        // UI Replay
        const replayBtn = document.getElementById('replay-btn');
        const replayOverlay = document.getElementById('replay-overlay');
        const replayVideo = document.getElementById('replay-video');
        const closeReplayBtn = document.getElementById('close-replay-btn');
        const ramBarFill = document.getElementById('ram-bar-fill');
        const ramText = document.getElementById('ram-text');
        const durationText = document.getElementById('duration-text'); // ELEMENT BARU

        // Zoom Elements
        const zoomSlider = document.getElementById('zoom-slider');
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnReset = document.getElementById('btn-reset');

        const motionStatusElement = document.getElementById('motion-status');
        const motionCanvas = document.getElementById('motion-comparison-canvas');
        const motionCtx = motionCanvas.getContext('2d', { willReadFrequently: true });
        let lastFrameData = null;
        let motionTimeoutId = null;
        
        let audioContext = null;
        let beepInterval = null;
        let beepCount = 0;
        let isBeeping = false;
        let isBeepMuted = false;
        
        const APP_ID = "bdc4d3eed2ba4f32bc2b81f9473fb816";
        const TOKEN = null;
        const CHANNEL = "cctv-channel-1";
        const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

        let remoteUser = null; 
        let isAudioMuted = false;
        let localMonitorAudioTrack = null; 
        let detectionModel = null;
        const objectsToDetect = ['person', 'car', 'motorcycle', 'bus', 'truck'];

        // --- VARIABLES DVR / RECORDING ---
        let mediaRecorder = null;
        let recordedChunks = []; // Buffer Video
        let totalBufferSize = 0;
        const MAX_BUFFER_SIZE = 1 * 1024 * 1024 * 1024; // 1 GB (byte)

        const speakerOnIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;
        const speakerOffIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
        const bellIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>`;
        const bellOffIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M1 1l22 22"></path></svg>`;

        // --- FUNGSI DVR RECORDING ---
        function startDVR(videoTrack, audioTrack) {
            const tracks = [videoTrack.getMediaStreamTrack()];
            if (audioTrack) {
                tracks.push(audioTrack.getMediaStreamTrack());
            }
            const stream = new MediaStream(tracks);

            const options = { mimeType: 'video/webm; codecs=vp8,opus' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                console.warn("VP8/Opus tidak didukung, menggunakan default.");
                delete options.mimeType;
            }

            mediaRecorder = new MediaRecorder(stream, options);
            mediaRecorder.ondataavailable = handleDataAvailable;
            mediaRecorder.start(1000); // 1 Detik per chunk
            console.log("DVR Recording dimulai...");
        }

        function handleDataAvailable(event) {
            if (event.data && event.data.size > 0) {
                recordedChunks.push(event.data);
                totalBufferSize += event.data.size;

                // Circular Buffer: Hapus data terlama jika > 1GB
                while (totalBufferSize > MAX_BUFFER_SIZE && recordedChunks.length > 0) {
                    const removedChunk = recordedChunks.shift(); 
                    totalBufferSize -= removedChunk.size;
                }

                updateRamIndicator();
            }
        }

        function updateRamIndicator() {
            // Update Bar RAM
            const sizeInMB = (totalBufferSize / (1024 * 1024)).toFixed(1);
            ramText.innerText = `${sizeInMB} MB / 1024 MB`;
            const percentage = Math.min((totalBufferSize / MAX_BUFFER_SIZE) * 100, 100);
            ramBarFill.style.width = `${percentage}%`;
            if (percentage > 90) ramBarFill.style.backgroundColor = '#d93025'; 
            else ramBarFill.style.backgroundColor = '#4CAF50';

            // Update Teks Durasi (Estimasi 1 chunk ~= 1 detik karena start(1000))
            const totalSeconds = recordedChunks.length;
            const h = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
            const s = (totalSeconds % 60).toString().padStart(2, '0');
            durationText.innerText = `Durasi: ${h}:${m}:${s}`;
        }

        // --- FUNGSI REPLAY ---
        replayBtn.addEventListener('click', () => {
            if (recordedChunks.length === 0) {
                alert("Belum ada data rekaman.");
                return;
            }
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            replayVideo.src = url;
            replayOverlay.style.display = 'flex';
        });

        closeReplayBtn.addEventListener('click', () => {
            replayVideo.pause();
            replayVideo.src = ""; 
            replayOverlay.style.display = 'none';
        });

        // --- LOGIKA ZOOM & PAN ---
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        const PAN_STEP = 50; 

        function updateControlsState() {
            const wrapperW = videoWrapper.clientWidth;
            const wrapperH = videoWrapper.clientHeight;
            const maxPanX = (wrapperW * currentZoom - wrapperW) / 2;
            const maxPanY = (wrapperH * currentZoom - wrapperH) / 2;

            if (currentPanX > maxPanX) currentPanX = maxPanX;
            if (currentPanX < -maxPanX) currentPanX = -maxPanX;
            if (currentPanY > maxPanY) currentPanY = maxPanY;
            if (currentPanY < -maxPanY) currentPanY = -maxPanY;

            if (currentZoom <= 1) {
                btnUp.disabled = true; btnDown.disabled = true;
                btnLeft.disabled = true; btnRight.disabled = true;
                currentPanX = 0; currentPanY = 0;
            } else {
                btnLeft.disabled = (currentPanX >= maxPanX);
                btnRight.disabled = (currentPanX <= -maxPanX);
                btnUp.disabled = (currentPanY >= maxPanY);
                btnDown.disabled = (currentPanY <= -maxPanY);
            }
            updateVideoTransform();
        }

        function updateVideoTransform() {
            const transformString = `translate(-50%, -50%) scale(${currentZoom}) translate(${currentPanX / currentZoom}px, ${currentPanY / currentZoom}px)`;
            remoteVideoElement.style.transform = transformString;
            canvasElement.style.transform = transformString;
        }

        zoomSlider.addEventListener('input', (e) => {
            currentZoom = parseFloat(e.target.value);
            updateControlsState(); 
        });

        btnUp.addEventListener('click', () => { currentPanY += PAN_STEP; updateControlsState(); });
        btnDown.addEventListener('click', () => { currentPanY -= PAN_STEP; updateControlsState(); });
        btnLeft.addEventListener('click', () => { currentPanX += PAN_STEP; updateControlsState(); });
        btnRight.addEventListener('click', () => { currentPanX -= PAN_STEP; updateControlsState(); });
        btnReset.addEventListener('click', () => {
            currentZoom = 1; zoomSlider.value = 1; updateControlsState();
        });

        document.addEventListener('keydown', (e) => {
            if (currentZoom <= 1) return;
            switch(e.key) {
                case 'ArrowUp': if (!btnUp.disabled) { e.preventDefault(); currentPanY += PAN_STEP; updateControlsState(); } break;
                case 'ArrowDown': if (!btnDown.disabled) { e.preventDefault(); currentPanY -= PAN_STEP; updateControlsState(); } break;
                case 'ArrowLeft': if (!btnLeft.disabled) { e.preventDefault(); currentPanX += PAN_STEP; updateControlsState(); } break;
                case 'ArrowRight': if (!btnRight.disabled) { e.preventDefault(); currentPanX -= PAN_STEP; updateControlsState(); } break;
            }
        });

        // --- FUNGSI ASLI ---
        function playBeep() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = 880; 
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        function startBeep() {
            if (isBeeping || isBeepMuted) return;
            isBeeping = true;
            beepCount = 0;
            beepInterval = setInterval(() => {
                if (beepCount >= 10) { stopBeep(); return; }
                playBeep();
                beepCount++;
            }, 1000); 
        }

        function stopBeep() {
            if (beepInterval) { clearInterval(beepInterval); beepInterval = null; }
            isBeeping = false; beepCount = 0;
        }

        function updateSpeakerButton() { toggleAudioBtn.innerHTML = isAudioMuted ? speakerOffIcon : speakerOnIcon; }
        function updateBeepButton() { 
            toggleBeepBtn.innerHTML = isBeepMuted ? bellOffIcon : bellIcon;
            if (isBeepMuted) toggleBeepBtn.classList.remove('unmuted');
            else toggleBeepBtn.classList.add('unmuted');
        }

        async function loadDetectionModel() {
            try {
                statusMessage.innerHTML += "<p>Memuat model AI...</p>";
                detectionModel = await cocoSsd.load();
                statusMessage.innerHTML = "<h2>Monitor Penerima</h2><p>Menunggu sinyal video dari kamera...</p>";
            } catch (err) {
                console.error("Gagal memuat model:", err);
            }
        }

        function detectMotion() {
            const width = 64; const height = 48;
            motionCanvas.width = width; motionCanvas.height = height;
            motionCtx.drawImage(remoteVideoElement, 0, 0, width, height);
            const currentFrame = motionCtx.getImageData(0, 0, width, height);
            
            if (lastFrameData) {
                let diff = 0;
                for (let i = 0; i < currentFrame.data.length; i += 4) {
                    diff += Math.abs(currentFrame.data[i] - lastFrameData.data[i]) + 
                            Math.abs(currentFrame.data[i+1] - lastFrameData.data[i+1]) + 
                            Math.abs(currentFrame.data[i+2] - lastFrameData.data[i+2]);
                }
                if ((diff / (width * height * 3)) > 1.5) { 
                    motionStatusElement.classList.remove('hidden');
                    if (!isBeeping) startBeep();
                    clearTimeout(motionTimeoutId);
                    motionTimeoutId = setTimeout(() => {
                        motionStatusElement.classList.add('hidden');
                        stopBeep();
                    }, 2000); 
                }
            }
            lastFrameData = currentFrame;
        }

        async function runDetectionAndMotion() {
            if (!detectionModel || remoteVideoElement.readyState < 3) {
                requestAnimationFrame(runDetectionAndMotion);
                return;
            }
            detectMotion();
            const predictions = await detectionModel.detect(remoteVideoElement);
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = remoteVideoElement.videoWidth;
            canvasElement.height = remoteVideoElement.videoHeight;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            predictions.forEach(prediction => {
                if (objectsToDetect.includes(prediction.class) && prediction.score > 0.6) {
                    const [x, y, width, height] = prediction.bbox;
                    ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 4;
                    ctx.fillStyle = '#FF0000'; ctx.font = '18px Arial';
                    ctx.strokeRect(x, y, width, height);
                    ctx.fillText(`${prediction.class} (${Math.round(prediction.score * 100)}%)`, x, y > 20 ? y - 5 : y + height + 20);
                }
            });
            requestAnimationFrame(runDetectionAndMotion);
        }

        async function startListening() {
            client.on("user-published", async (user, mediaType) => {
                await client.subscribe(user, mediaType);
                remoteUser = user; 
                
                if (mediaType === "video") {
                    statusMessage.classList.add('hidden');
                    user.videoTrack.play(remoteVideoElement);
                    
                    startDVR(user.videoTrack, user.audioTrack);

                    remoteVideoElement.onloadedmetadata = () => {
                        runDetectionAndMotion();
                        updateControlsState();
                    };
                }
                if (mediaType === "audio") {
                    user.audioTrack.play();
                    user.audioTrack.setVolume(isAudioMuted ? 0 : 100);
                }
            });
            client.on("user-unpublished", (user, mediaType) => {
                if (mediaType === 'video') {
                    if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
                    remoteVideoElement.srcObject = null;
                    const ctx = canvasElement.getContext('2d');
                    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    lastFrameData = null;
                    remoteUser = null;
                    statusMessage.classList.remove('hidden');
                }
            });
            try {
                await client.join(APP_ID, CHANNEL, TOKEN, null);
            } catch (err) {
                statusMessage.innerHTML = `<h2>Error</h2><p>${err.message}</p>`;
            }
        }

        toggleAudioBtn.addEventListener('click', () => {
            if (!remoteUser || !remoteUser.audioTrack) return;
            isAudioMuted = !isAudioMuted;
            remoteUser.audioTrack.setVolume(isAudioMuted ? 0 : 100);
            updateSpeakerButton();
        });

        toggleBeepBtn.addEventListener('click', () => {
            isBeepMuted = !isBeepMuted; updateBeepButton();
            if (isBeepMuted && isBeeping) stopBeep();
        });

        const startTalk = async () => {
            if (localMonitorAudioTrack) return; 
            pushToTalkBtn.classList.add('active');
            try {
                if (remoteUser && remoteUser.audioTrack) remoteUser.audioTrack.setVolume(0);
                localMonitorAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                await client.publish(localMonitorAudioTrack);
            } catch (err) { pushToTalkBtn.classList.remove('active'); }
        };

        const stopTalk = async () => {
            if (!localMonitorAudioTrack) return;
            pushToTalkBtn.classList.remove('active');
            try {
                await client.unpublish(localMonitorAudioTrack);
                localMonitorAudioTrack.stop(); localMonitorAudioTrack.close(); localMonitorAudioTrack = null;
                if (remoteUser && remoteUser.audioTrack && !isAudioMuted) remoteUser.audioTrack.setVolume(100);
            } catch (err) { console.error(err); }
        };

        pushToTalkBtn.addEventListener('mousedown', startTalk);
        pushToTalkBtn.addEventListener('mouseup', stopTalk);
        pushToTalkBtn.addEventListener('mouseleave', stopTalk); 
        pushToTalkBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startTalk(); });
        pushToTalkBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopTalk(); });

        startButton.addEventListener('click', () => {
            startOverlay.style.display = 'none';
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            updateSpeakerButton(); updateBeepButton();
            loadDetectionModel(); startListening(); updateControlsState(); 
        });
    </script>
</body>
</html>


